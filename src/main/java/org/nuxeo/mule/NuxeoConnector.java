/**
 * This file was automatically generated by the Mule Development Kit
 */
package org.nuxeo.mule;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import org.mule.api.ConnectionException;
import org.mule.api.annotations.Configurable;
import org.mule.api.annotations.Connect;
import org.mule.api.annotations.ConnectionIdentifier;
import org.mule.api.annotations.Connector;
import org.mule.api.annotations.Disconnect;
import org.mule.api.annotations.Processor;
import org.mule.api.annotations.Transformer;
import org.mule.api.annotations.ValidateConnection;
import org.mule.api.annotations.display.Password;
import org.mule.api.annotations.display.Placement;
import org.mule.api.annotations.param.ConnectionKey;
import org.mule.api.annotations.param.Optional;
import org.nuxeo.ecm.automation.client.AutomationClient;
import org.nuxeo.ecm.automation.client.OperationRequest;
import org.nuxeo.ecm.automation.client.Session;
import org.nuxeo.ecm.automation.client.adapters.DocumentService;
import org.nuxeo.ecm.automation.client.jaxrs.impl.HttpAutomationClient;
import org.nuxeo.ecm.automation.client.model.DocRef;
import org.nuxeo.ecm.automation.client.model.Document;
import org.nuxeo.ecm.automation.client.model.Documents;
import org.nuxeo.ecm.automation.client.model.FileBlob;
import org.nuxeo.ecm.automation.client.model.OperationDocumentation;
import org.nuxeo.ecm.automation.client.model.StringBlob;
import org.nuxeo.ecm.automation.client.model.OperationDocumentation.Param;

/**
 * Connector that uses Nuxeo Automation java client to leverage Nuxeo Rest API
 * 
 * @author <a href="mailto:tdelprat@nuxeo.com">Tiry</a>
 * 
 */
@Connector(name = "nuxeo", schemaVersion = "1.0-SNAPSHOT")
public class NuxeoConnector extends BaseDocumentService {

    /**
     * Nuxeo Server name (IP or DNS name)
     */
    @Configurable
    @Placement(group = "Connection")
    private String serverName;

    /**
     * Port used to connect to Nuxeo Server
     */
    @Configurable
    @Placement(group = "Connection")
    private String port;

    /**
     * Context Path for Nuxeo instance
     */
    @Configurable
    @Placement(group = "Connection")
    private String contextPath = "nuxeo";

    public NuxeoConnector() {
        serverName = "localhost";
        port = "8080";
        contextPath = "nuxeo";
    }

    /**
     * get Nuxeo Server Name
     * 
     * @return Nuxeo Server Name
     */
    public String getServerName() {
        return serverName;
    }

    /**
     * get Nuxeo Server Port
     * 
     * @return Nuxeo Server Port
     */
    public String getPort() {
        return port;
    }

    /**
     * get Nuxeo Server Context pat
     * 
     * @return Nuxeo Server Context path
     */
    public String getContextPath() {
        return contextPath;
    }

    /**
     * set Nuxeo Server name
     * 
     * @param serverName
     */
    public void setServerName(String serverName) {
        this.serverName = serverName;
    }

    /**
     * set port used to connect to Nuxeo Server
     * 
     * @param port
     */
    public void setPort(String port) {
        this.port = port;
    }

    /**
     * set Context path of the target Nuxeo Server
     * 
     * @param contextPath
     */
    public void setContextPath(String contextPath) {
        this.contextPath = contextPath;
    }

    private Session session;

    protected String getServerUrl() {
        return "http://" + serverName + ":" + port + "/" + contextPath
                + "/site/automation";
    }

    /**
     * Connect to Nuxeo Server via Automation java client
     * 
     * @param username Nuxeo user name
     * @param password Nuxeo password
     * @throws ConnectionException
     */
    @Connect
    public void connect(@ConnectionKey
    String username, @Password
    String password) throws ConnectionException {
        AutomationClient client = new HttpAutomationClient(getServerUrl());
        session = client.getSession(username, password);

        docService = session.getAdapter(DocumentService.class);
    }

    /**
     * Disconnect
     */
    @Disconnect
    public void disconnect() {
        if (session != null) {
            session.close();
        }
    }

    /**
     * Are we connected
     * 
     * @return true if an Automation Session is active
     */
    @ValidateConnection
    public boolean isConnected() {
        return (session != null);
    }

    /**
     * Are we connected
     * 
     * @return fake ConnectionId based on serverUrl and username
     */
    @ConnectionIdentifier
    public String connectionId() {
        if (session != null) {
            return getServerUrl() + session.getLogin();
        } else {
            return getServerUrl();
        }
    }

    /**
     * Executes an arbitrary operation
     * 
     * @param operationName Name of the Automation Operation
     * @param input Input of the Operation
     * @param params Parameters of the Operation
     * @return Result of the Operation
     * @throws Exception
     */
    @Processor
    public Object runOperation(@Placement(group = "operation parameters")
    String operationName, @Placement(group = "operation parameters")
    @Optional
    Object input, @Optional
    @Placement(group = "operation parameters")
    Map<String, String> params) throws Exception {
        OperationRequest request = session.newRequest(operationName);
        OperationDocumentation opDef = request.getOperation();

        // fill operation parameter according to signature
        for (Param param : opDef.getParams()) {
            for (String pname : params.keySet()) {
                if (pname.equals(param.getName())) {
                    request.set(pname, params.get(pname));
                    break;
                }
            }
        }

        if (input != null) {
            String[] sig = opDef.getSignature();
            for (int i = 0; i < sig.length; i = i + 2) {
                String inputType = sig[i];
                if (inputType.equals("Document")) {
                    request.setInput(new DocRef(input.toString()));
                } else if (inputType.equals("Blob")) {
                    if (input instanceof File) {
                        request.setInput(new FileBlob((File) input));
                    }
                }
            }
        }
        return request.execute();
    }

    /****************************** Transformers **************/

    /**
     * @Mime(MimeTypes.JSON)
     * @Transformer(sourceTypes = { Document.class }) public static String
     *                          documentToJSON(Document doc) {
     * 
     *                          return null; }
     **/

    /**
     * Creates a Blob from a File
     * 
     * @param file the input File
     * @return the Blob wrapping the File
     */
    @Transformer(sourceTypes = { File.class })
    public static FileBlob fileToBlob(File file) {
        return new FileBlob(file);
    }

    /**
     * Creates a Blob from a String
     * 
     * @param file the input String
     * @return the Blob wrapping the String
     */
    @Transformer(sourceTypes = { String.class })
    public static StringBlob stringToBlob(String input) {
        return new StringBlob(input);
    }

    /**
     * Convert a Document to a Simple Map
     * 
     * @param doc the Document to convert
     * @return the resulting Map<String, Object>
     */
    @Transformer(sourceTypes = { Document.class })
    public static Map<String, Object> documentToMap(Document doc) {
        Map<String, Object> map = doc.getProperties().map();
        map.put("type", doc.getType());
        map.put("facets", doc.getFacets().list());
        map.put("id", doc.getId());
        map.put("lock", doc.getLock());
        map.put("lockCreated", doc.getLockCreated());
        map.put("lockOwner", doc.getLockOwner());
        map.put("path", doc.getPath());
        map.put("repository", doc.getRepository());
        map.put("state", doc.getState());
        return map;
    }

    /**
     * Converts a list of Documents into a simple list of Map
     * 
     * @param docs the Documents list to convert
     * @return the resulting List of Map
     */
    @Transformer(sourceTypes = { Documents.class })
    public static List<Map<String, Object>> documentsToListOfMap(Documents docs) {
        List<Map<String, Object>> result = new ArrayList<Map<String, Object>>();
        for (Document doc : docs) {
            result.add(documentToMap(doc));
        }
        return result;
    }
}
